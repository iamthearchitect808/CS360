# CS360

  This app was required to include user login functionality to allow separation of events by user. The password field had to obscure the characters typed, for added security. It required user registration functionality, which I placed in the intent of a registration button on the login screen. User login information was also verified against the database before entry to the app. To accomplish these, I made fields and buttons in the horizontal center of the screen, to support the top-to-bottom visual hierarchy and prevent buttons or features from being missed, or hidden in corners of the screen. The database used Room and SQLite, along with verification functions which displayed toast messages when invalid credentials were entered. 
  Another requirement was to display event data using a grid, which I accomplished by using a RecyclerView fragment with cardview cards inside, enabling vertical scrolling of an event list. In the event that there are more events than can display at one time on the screen, the RecyclerView anticipates the next card which must display and prepares it within memory, but only about seven events must be stored in display memory at one time. 
  A button to add new events was required, which I placed in a custom app bar at the top of the screen. CRUD functions supported the functioning of inserting, editing, deleting and displaying events from the database to the view screen. SMS messaging permission was required to be requested of the users, which I accomplished by placing a sign-up option in the hidden menu of the custom app bar, which updated the user database table according to the option chosen. I also added the SMS RECEIVE permission into the App Manifest and created a loop to generate an SMS message intent for all events happening on the current day.
  Several separate activities and screens were needed in order to make this app function, and to create a logical path through each user story. Activity intents were integral to accomplishing this, with SAVE, SUBMIT, DELETE, and other buttons launching new fullscreen activities, or returning the user to the main activity. The use of these screen transitions prevented the need for tapping the "previous" button to back out of an activity. My UI design also considered the preference of the user for intuitive and minimal tapping within user stories. I followed the logical steps of transitional flow between activities, and tried to minimize possible actions within any one screen. 
  My process of coding the app was through trial and error as I both learned class methods and adjusted my development plan as I went. Much research was needed to get any features to work, and I focused on one integrative task at a time, verifying functionality whenever significant changes were made. More disciplined testing would have been useful to save the need to re-run the app after changes, which always required logging in and creating, editing, or deleting more events. 
  I had to innovate throughout the development of this app to overcome the challenges presented by the combining features into one cohesive application. To make the cardview work with the recyclerview, to use custom functions within the user and events database tables, to query custom selections from the tables, to implement a custom app bar, and to create an SMS intent function all required sufficient understanding of the related components, an ability to seek out answers from other people as to how to do similar things, and to glue functions together with custom code.
  The foremost component of my app which successfully demonstrates my skills and experience was the division of the app into the Model-View-Controller architecture, and adhering to this structure throughout development. Past challenges for me have been to sufficiently modularize to that component responsibilities remain separated, and as little is found within the main class as possible. I also was able counter my natural tendency to overcomplicate my engineering of functional units, which worked well for me as I figured out how best to work with date and time information passing from view to model and back. 
